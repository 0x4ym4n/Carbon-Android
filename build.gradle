buildscript {

    ext {
        androidPluginVersion            = '3.1.2'
        kotlinVersion                   = '1.2.41'

        // android
        androidLifecycleVersion         = '1.1.1'
        constraintLayoutVersion         = '1.1.0'
        supportVersion                  = '27.1.1'
        playServicesVersion             = '15.0.0'

        // third party
        daggerVersion                   = '2.14.1'
        fabricToolsVersion              = '1.25.2'
        gradleVersionsPluginVersion     = '0.17.0'
        gsonVersion                     = '2.8.2'
        hugoVersion                     = '1.2.1'
        leakcanaryVersion               = '1.5.4'
        okHttpVersion                   = '3.9.1'
        retrofitRxAdapterVersion        = '2.3.0'
        retrofitVersion                 = '2.3.0'
        rxAndroidVersion                = '2.0.2'
        rxJavaVersion                   = '2.1.8'
        timberVersion                   = '4.7.0'

        // testing
        androidTestSupportVersion       = '1.0.1'
        daggerMockVersion               = '0.8.4'
        espressoVersion                 = '3.0.1'
        junitVersion                    = '4.12'
        mockitoKotlinVersion            = '1.5.0'
        mockitoVersion                  = '2.13.0'
        robolectricVersion              = '3.7.1'
        testButlerVersion               = '1.3.1'
    }

    repositories {
        google()
        jcenter()
    }

    dependencies {
        classpath "com.android.tools.build:gradle:$androidPluginVersion"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
        classpath "org.jetbrains.kotlin:kotlin-allopen:$kotlinVersion"
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        mavenCentral()
        maven { url "https://jitpack.io" }
    }

    // Automatically pull down javadocs and sources (if available)
    apply plugin: 'idea'
    idea {
        module {
            downloadJavadoc = true
            downloadSources = true
        }
    }

    // Verbose output for usage of deprecated APIs
    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:deprecation"
    }
}

// Disable predexing (enable on build servers)
project.ext.preDexLibs = !project.hasProperty('disablePreDex')
subprojects {
    project.plugins.whenPluginAdded { plugin ->
        if ("com.android.build.gradle.AppPlugin".equals(plugin.class.name)) {
            project.android.dexOptions.preDexLibraries = rootProject.ext.preDexLibs
        } else if ("com.android.build.gradle.LibraryPlugin".equals(plugin.class.name)) {
            project.android.dexOptions.preDexLibraries = rootProject.ext.preDexLibs
        }
    }
}

// Prevent wildcard dependencies
// https://gist.github.com/JakeWharton/2066f5e4f08fbaaa68fd
allprojects {
    afterEvaluate { project ->
        project.configurations.all {
            resolutionStrategy.eachDependency { DependencyResolveDetails details ->
                def requested = details.requested
                if (requested.version.contains('+')) {
                    throw new GradleException("Wildcard dependency forbidden: ${requested.group}:${requested.name}:${requested.version}")
                }
            }
        }
    }
}

ext {
    // Build (this implementation assumes values are being provided as arguments, perhaps by a build server)
    appVersion = "1.0"
    versionFingerprint = project.hasProperty("fingerprint") ? ("\"" + fingerprint + "\"") : "\"DEV\""
    versionCode = project.hasProperty("buildNumber") ? Integer.parseInt(buildNumber) : 1
    versionName = "$appVersion b$versionCode"

    // Build settings that are likely to be reused across different modules
    minSdkVersion = 21
    targetSdkVersion = 27
    compileSdkVersion = 27
}

evaluationDependsOnChildren()

task initialCleanup() {
    def cleanTasks = getProjectTask(this, 'clean')
    def uninstallTasks = getProjectTask(this, 'uninstallAll')

    dependsOn cleanTasks
    dependsOn uninstallTasks
}

task staticAnalysis {
    def appProject = subprojects.find { project -> 'app' == project.name }

    def findBugsTasks = getProjectTask(appProject, 'findbugs')
    def pmdTasks = getProjectTask(appProject, 'pmd')
    def lintTasks = getProjectTask(appProject, 'lint')
    def checkstyleTasks = getProjectTask(appProject, 'checkstyle')

    dependsOn findBugsTasks
    dependsOn pmdTasks
    dependsOn lintTasks
    dependsOn checkstyleTasks
}

task testing() {
    def appProject = subprojects.find { project -> 'app' == project.name }

    def unitTestTasks = getProjectTask(appProject, 'testDevDebugUnitTest')
    def integrationTestTasks = getProjectTask(appProject, 'connectedDevDebugAndroidTest')

    dependsOn unitTestTasks
    dependsOn integrationTestTasks

    integrationTestTasks.each { task -> task.mustRunAfter unitTestTasks }
}

task release() {
    def appProject = subprojects.find { project -> 'app' == project.name }

    def appTasks = getProjectTask(appProject, 'assemble')

    dependsOn appTasks
}

static def getProjectTask(project, taskName) {
    def tasks = project.getTasksByName(taskName, true)
    if (tasks == null || tasks.empty) {
        throw new IllegalArgumentException("Task " + taskName + " not found")
    }
    return tasks
}

task continuousIntegration() {
    dependsOn initialCleanup
    dependsOn staticAnalysis
    dependsOn testing
    dependsOn release

    // Static analysis first, then testing, then release
    staticAnalysis.mustRunAfter initialCleanup
    testing.mustRunAfter staticAnalysis
    release.mustRunAfter testing
}
